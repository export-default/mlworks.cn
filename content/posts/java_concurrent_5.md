+++
author = "Ryan Zhao"
categories = ["Java","并发编程"]
date = "2016-04-21T13:50:48+08:00"
description = "关于volatile的实现方式，以及编译器、CPU如何保证happens-before约束。"
keywords = ["Java并发编程","高性能并发"]
mathjax = false
tags = ["并发","Java"]
title = "Java极致并发：（五）reordering与volatile"

+++

<div>
<span><div>第一篇中提到volatile有讲到，JMM（Java Memory Model）定义了happens-before关系来保证对volatile变量读写的可见性约束。这种happens-before的关系需要编译器和处理器一起维护。本文简述了一些Java compiler如何保证happens-before语义的一些方法，详细内容可以参考<a href="http://gee.cs.oswego.edu/dl/jmm/cookbook.html">JMM-COOKBOOK</a>。关于内存屏障的详细解释，请参考<a href="http://www.puppetmastertrading.com/images/hwViewForSwHackers.pdf">Memory Barriers: a Hardware View for Software Hackers</a>。</div><div><br/></div><div>一、编译器Reordering</div><div><br/></div><div>我们知道编译器会对我们的代码进行优化，只需要保证as-if-sequential的一致性即可。reordering（重排）即是其中的一种优化方法，其通过重排内存读写顺序用以优化程序性能。</div><div><br/></div><div>在多线程环境中，重排读写指令会带来一些问题。如，将synchronized内部的读指令，重排到synchronized外部，显然是一个错误，应为synchronized内部的读指令有可见性保证，而重排后没有了可见性保证，可能会读取到旧的值。</div><div><br/></div><div>也就是说，读写指令的重排可能违背JMM中happens-before的约束。因此，某些操作是不能重排的。根据JMM中关于happens-before关系的定义，可以得到下面的表格。</div><div><br/></div><table border="1" cellpadding="1" cellspacing="1" style="font-family: Simsun; letter-spacing: normal; orphans: auto; text-indent: 0px; text-transform: none; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;width:416px;"><tr><td align="center" style="width:25%;"><b>Can Reorder</b></td><td align="center" colspan="4" rowspan="1" style="width:73.79807692307693%;"><em>2nd operation</em></td></tr><tr><td><em>1st operation</em></td><td>Normal Load<br/>
Normal Store</td><td>Volatile Load <br/>
MonitorEnter</td><td>Volatile Store <br/>
MonitorExit</td></tr><tr><td>Normal Load<br/>
Normal Store</td><td><br/></td><td><div><br/></div></td><td><div>No</div></td></tr><tr><td>Volatile Load 
<div>MonitorEnter</div></td><td><div>No</div></td><td><div>No</div></td><td><div>No</div></td></tr><tr><td>Volatile store <br/>
MonitorExit</td><td><div><br/></div></td><td><div>No</div></td><td><div>No</div></td></tr></table><div><br/></div><div>二、CPU Reordering</div><div><br/></div><div>出了编译器会重排优化指令外，CPU也会乱序执行指令，只需要保证as-if-sequential的一致性。在多线程环境下，CPU提供了一些内存屏障指令，来禁止这种重排，从而维持happens-before关系。</div><ol><li>LoadLoad屏障：Load1; LoadLoad; Load2，保证Load1先于Load2以及其后所有Load指令加载。</li><li>StoreStore屏障：Store1; StoreStore; Store2，保证Store1先于Store2以及其后所有Store指令，被flush。</li><li>LoadStore屏障：Load1; LoadStore; Store2，保证Load1在Store2以及其后所有Store指令flush之前加载。</li><li>StoreLoad屏障：Store1; StoreLoad; Load2，保证Store1先于Load2以及其后所有Load指令，被flush。</li></ol><div>被flush即写入主存，将被所有处理器可见。</div><div><br/></div><div>从语义上来看，LoadLoad、LoadStore操作应该比较廉价，StoreStore和StoreLoad操作比较昂贵（涉及到写主存以及高速缓存协商等）。</div><div><br/></div><div><table border="1" cellpadding="2" cellspacing="2" style="font-family: Simsun; letter-spacing: normal; orphans: auto; text-indent: 0px; text-transform: none; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;width:544px;"><tr><td align="center" style="width:25.735294117647058%;"><b>Required barriers</b></td><td align="center" colspan="4" rowspan="1" style="width:72.79411764705883%;"><em>2nd operation</em></td></tr><tr><td><em>1st operation</em></td><td>Normal Load</td><td>Normal Store</td><td>Volatile Load <br/>
MonitorEnter</td><td>Volatile Store <br/>
MonitorExit</td></tr><tr><td>Normal Load</td><td><br/></td><td><br/></td><td><br/></td><td><font color="red">LoadStore</font></td></tr><tr><td>Normal Store</td><td><br/></td><td><br/></td><td><br/></td><td><font color="red">StoreStore</font></td></tr><tr><td>Volatile Load <br/>
MonitorEnter</td><td><font color="red">LoadLoad</font></td><td><font color="red">LoadStore</font></td><td><font color="red">LoadLoad</font></td><td><font color="red">LoadStore</font></td></tr><tr><td>Volatile Store <br/>
MonitorExit</td><td><br/></td><td><br/></td><td><font color="red">StoreLoad</font></td><td><font color="red">StoreStore</font></td></tr></table></div><div><br/></div><div>上表即编译器应该在相关操作中间插入的屏障指令。</div><div><br/></div><div>三、volatile的读写性能</div><div><br/></div><div>从前面的讨论可以看到，volatile的写操作比读操作要昂贵许多。本文通过使用<a href="http://openjdk.java.net/projects/code-tools/jmh/">JMH</a>来测试volatile读写与非volatile的性能差距。测试结果如下</div><div><br/></div><table style="box-sizing: border-box; border-spacing: 0px; border-collapse: collapse; margin-bottom: 20px; border: 1px solid rgb(221, 221, 221); font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);width:750px;"><tr style="box-sizing: border-box;"><td style="box-sizing: border-box; padding: 5px; vertical-align: top; border: 1px solid rgb(221, 221, 221);width:59.599999999999994%;">Benchmark</td><td style="box-sizing: border-box; padding: 5px; vertical-align: top; border: 1px solid rgb(221, 221, 221);width:7.866666666666666%;">Mode</td><td style="box-sizing: border-box; padding: 5px; vertical-align: top; border: 1px solid rgb(221, 221, 221);width:5.466666666666667%;">Cnt</td><td style="box-sizing: border-box; padding: 5px; vertical-align: top; border: 1px solid rgb(221, 221, 221);width:8.266666666666666%;">Score</td><td style="box-sizing: border-box; padding: 5px; vertical-align: top; border: 1px solid rgb(221, 221, 221);width:10.4%;">Error</td><td style="box-sizing: border-box; padding: 5px; vertical-align: top; border: 1px solid rgb(221, 221, 221);width:8.266666666666666%;">Units</td></tr><tr style="box-sizing: border-box;"><td style="box-sizing: border-box; padding: 5px; vertical-align: top; border: 1px solid rgb(221, 221, 221);">VolatileLoadStoreBenchmark.measureNormalLoad</td><td style="box-sizing: border-box; padding: 5px; vertical-align: top; border: 1px solid rgb(221, 221, 221);">avgt</td><td style="box-sizing: border-box; padding: 5px; vertical-align: top; border: 1px solid rgb(221, 221, 221);">10</td><td style="box-sizing: border-box; padding: 5px; vertical-align: top; border: 1px solid rgb(221, 221, 221);">2.324</td><td style="box-sizing: border-box; padding: 5px; vertical-align: top; border: 1px solid rgb(221, 221, 221);">± 0.014</td><td style="box-sizing: border-box; padding: 5px; vertical-align: top; border: 1px solid rgb(221, 221, 221);">ns/op</td></tr><tr style="box-sizing: border-box;"><td style="box-sizing: border-box; padding: 5px; vertical-align: top; border: 1px solid rgb(221, 221, 221);">VolatileLoadStoreBenchmark.measureNormalStore</td><td style="box-sizing: border-box; padding: 5px; vertical-align: top; border: 1px solid rgb(221, 221, 221);">avgt</td><td style="box-sizing: border-box; padding: 5px; vertical-align: top; border: 1px solid rgb(221, 221, 221);">10</td><td style="box-sizing: border-box; padding: 5px; vertical-align: top; border: 1px solid rgb(221, 221, 221);">0.386</td><td style="box-sizing: border-box; padding: 5px; vertical-align: top; border: 1px solid rgb(221, 221, 221);">± 0.003</td><td style="box-sizing: border-box; padding: 5px; vertical-align: top; border: 1px solid rgb(221, 221, 221);">ns/op</td></tr><tr style="box-sizing: border-box;"><td style="box-sizing: border-box; padding: 5px; vertical-align: top; border: 1px solid rgb(221, 221, 221);">VolatileLoadStoreBenchmark.measureVolatileLoad</td><td style="box-sizing: border-box; padding: 5px; vertical-align: top; border: 1px solid rgb(221, 221, 221);">avgt</td><td style="box-sizing: border-box; padding: 5px; vertical-align: top; border: 1px solid rgb(221, 221, 221);">10</td><td style="box-sizing: border-box; padding: 5px; vertical-align: top; border: 1px solid rgb(221, 221, 221);">2.340</td><td style="box-sizing: border-box; padding: 5px; vertical-align: top; border: 1px solid rgb(221, 221, 221);">± 0.088</td><td style="box-sizing: border-box; padding: 5px; vertical-align: top; border: 1px solid rgb(221, 221, 221);">ns/op</td></tr><tr style="box-sizing: border-box;"><td style="box-sizing: border-box; padding: 5px; vertical-align: top; border: 1px solid rgb(221, 221, 221);">VolatileLoadStoreBenchmark.measureVolatileStore</td><td style="box-sizing: border-box; padding: 5px; vertical-align: top; border: 1px solid rgb(221, 221, 221);">avgt</td><td style="box-sizing: border-box; padding: 5px; vertical-align: top; border: 1px solid rgb(221, 221, 221);">10</td><td style="box-sizing: border-box; padding: 5px; vertical-align: top; border: 1px solid rgb(221, 221, 221);">5.815</td><td style="box-sizing: border-box; padding: 5px; vertical-align: top; border: 1px solid rgb(221, 221, 221);">± 0.013</td><td style="box-sizing: border-box; padding: 5px; vertical-align: top; border: 1px solid rgb(221, 221, 221);"><div>ns/op</div></td></tr></table><div>测试机器为Intel Core i7-4710MQ。可以看到volatile store的性能要比nomal store低近一个数量级。</div><div><br/></div><div>相关代码在此处：<a href="https://github.com/ryanzz/jconcurrency/blob/master/src/main/java/cn/mlworks/jconcurrency/VolatileLoadStoreBenchmark.java">Github</a></div><div><br/></div><div>下一篇文章，将会对synchronized、Lock、CAS等同步工具的性能给出测试。</div></span>
</div>